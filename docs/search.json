[
  {
    "objectID": "uv.html",
    "href": "uv.html",
    "title": "uv",
    "section": "",
    "text": "The uv program is a Python package and project manager. It is like pip or virtualenv (sort of like conda) but it is much faster and more modern. We will be using uv in the course to demo code and you will be using uv for your homework assignments.\n\na uv guide: working on projects\nproject concepts in uv"
  },
  {
    "objectID": "uv.html#what-is-uv",
    "href": "uv.html#what-is-uv",
    "title": "uv",
    "section": "",
    "text": "The uv program is a Python package and project manager. It is like pip or virtualenv (sort of like conda) but it is much faster and more modern. We will be using uv in the course to demo code and you will be using uv for your homework assignments.\n\na uv guide: working on projects\nproject concepts in uv"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Introduction to the Course",
    "section": "",
    "text": "Welcome! I’m glad you’re here.\nThis is Psychology 9040: Scientific Computing, for FW25, Jan-Apr 2026.\nBring your computer to class! We will be writing code.\nCourse website: https://gribblelab.org/9040"
  },
  {
    "objectID": "intro.html#course-goals",
    "href": "intro.html#course-goals",
    "title": "Introduction to the Course",
    "section": "Course Goals",
    "text": "Course Goals\nIn this one-semester graduate course you will learn skills in scientific computing—tools and techniques that you can use in your own research. You will learn to program using Python, which is a high-level programming language with many libraries that provide a rich ecosystem for scientific computing. If you want to use a different language in the course you are welcome to but I will focus on Python in class. Having said that, as much as I can I will teach concepts in a way that are language-agnostic.\nThe course is designed to achieve three primary goals:\n\nYou will learn to write code in a high-level language (Python)\nYou will learn to think computationally and algorithmically about data analysis\nYou will learn some common data analysis techniques, which will give you a foundation from which to learn more complex scientific computing skills to suit your own research goals"
  },
  {
    "objectID": "intro.html#topics",
    "href": "intro.html#topics",
    "title": "Introduction to the Course",
    "section": "Topics",
    "text": "Topics\nIn the first part of the course you will learn how to write code. The topics we will cover are common to any high-level language including Python, MATLAB, R, Javascript, C, Julia, Go, Swift, etc. All high level languages have things like numbers, strings, arrays, loops, if-statements. Languages differ in their syntax, in the names of common functions, and sometimes in some other subtle ways (e.g. passing by reference vs passing by value) but otherwise, all high-level languages basically work in the same way. Learning these fundamental concepts of high-level programming languages using one language will enable you to learn other languages as well in the future.\nThe other aspect of programming that you will learn is how to think algorithmically about solving problems and completing tasks with computers. In general there are two reasons to use a computer to perform a given task, (1) because the task would take too long by hand (e.g. churning through processing a huge amount of data), and (2) because the computer can do something clever that you cannot do yourself (e.g. applying complex algorithms to a dataset).\nIn learning the fundamentals of high-level programming languages (data types, loops, conditionals, etc) we will sometimes practice writing code to solve little toy problems. This will start to teach you how to think algorithmically. Think about it like learning to play a musical instrument. You don’t start by learining to play Beethoven. You start learning basic skills by playing scales, arpeggios, different key signatures, etc. Building up basic skills using toy problems is a convenient path towards using coding skills to solve real-world programming problems in the context of your own thesis research.\nWe will also practice and learn by using code to answer questions about data. Some of the data will be from real experiments and some will be fictitious. The goal will be to answer a series of questions by writing code that performs operations on the data (reorganization, summarising, counting, calculating, processing, plotting, etc) and writing a short summary of your findings. This mimics how you will be using your coding skills in your own research going forward.\n\nFundamentals of Coding\n\ndigital representation of data\nbasic data types, operators, & expressions\ncontrol flow & conditionals\nfunctions\ncomplex data types\nfile input & output\ngraphical displays of data\nobject oriented programming (OOP)\n\n\n\nReproducibility & Replicability\n\nPython venvs (virtual environments)\nCode versioning using Git & GitHub\norganization of code and data\ndata analysis workflow\n\n\n\nTopics in Data Analysis\n\nsampling, signal processing, & filtering data\nstatistical tests (parametric vs resampling/boostrapping/randomization)\nfitting models to data\nsimulating dynamical systems\n\nBy building upon the foundational knowledge and skills you have acquired in this course, you will be able to learn other techniques in programming and in data analysis as your scientific research progresses."
  },
  {
    "objectID": "hw/hw03.html",
    "href": "hw/hw03.html",
    "title": "Homework 3",
    "section": "",
    "text": "Due: Feb 1 by 11:59 pm eastern standard time\nSubmit a single file called name_03.py to Brightspace/OWL where name is replaced with your last name, e.g. gribble_03.py\n\nWrite a Python program to complete the Square Digit Chains exercise.\nHint: the answer is a 7 digit number starting with 8 and ending in 6 … and if you add all the digits up you get 33."
  },
  {
    "objectID": "hw/hw01.html",
    "href": "hw/hw01.html",
    "title": "Homework 1",
    "section": "",
    "text": "Due: Jan 18 by 11:59 pm eastern standard time\nSubmit a single file called name_01.py to Brightspace/OWL where name is replaced with your last name, e.g. gribble_01.py\n\nWrite some code to complete the Parabolic Flight coding exercise. Make sure it produces the correct output given the example inputs, including the same number of decimal places."
  },
  {
    "objectID": "git.html",
    "href": "git.html",
    "title": "Git & GitHub",
    "section": "",
    "text": "First, if you don’t have a GitHub account already, go and sign up for a (free) GitHub account.\nThen, double-check that you have installed git as part of the setup instructions. Open up a terminal and type:\ngit --version\nand you should get something like:\ngit version 2.34.0\nIt doesn’t much matter if the version number isn’t identical to the one above."
  },
  {
    "objectID": "git.html#setup",
    "href": "git.html#setup",
    "title": "Git & GitHub",
    "section": "",
    "text": "First, if you don’t have a GitHub account already, go and sign up for a (free) GitHub account.\nThen, double-check that you have installed git as part of the setup instructions. Open up a terminal and type:\ngit --version\nand you should get something like:\ngit version 2.34.0\nIt doesn’t much matter if the version number isn’t identical to the one above."
  },
  {
    "objectID": "git.html#tutorials-intros",
    "href": "git.html#tutorials-intros",
    "title": "Git & GitHub",
    "section": "Tutorials / Intros",
    "text": "Tutorials / Intros\n\nabout GitHub and Git by GitHub docs\ngit-novice by software carpentry\nhello world by GitHub docs\nGit Cheat Sheet by GitHub Education\nGit project page"
  },
  {
    "objectID": "functions_file_io.html",
    "href": "functions_file_io.html",
    "title": "Functions, File input & output",
    "section": "",
    "text": "Learning with Python 3 chapter 4: Functions\nThink Python Chapter 3\nPython for Data Analysis chapter 3.2: Functions\nPython for Data Analysis chapter 3.3: Files and the Operating System\nPython for Data Analysis chapter 6: Data Loading, Storage, and File Formats"
  },
  {
    "objectID": "functions_file_io.html#readings",
    "href": "functions_file_io.html#readings",
    "title": "Functions, File input & output",
    "section": "",
    "text": "Learning with Python 3 chapter 4: Functions\nThink Python Chapter 3\nPython for Data Analysis chapter 3.2: Functions\nPython for Data Analysis chapter 3.3: Files and the Operating System\nPython for Data Analysis chapter 6: Data Loading, Storage, and File Formats"
  },
  {
    "objectID": "control_flow_and_complex_data_types.html",
    "href": "control_flow_and_complex_data_types.html",
    "title": "Control Flow & Complex data types",
    "section": "",
    "text": "Here we will learn above several ways to specify the flow of information as your code gets executed. We will learn about loops, which are constructs that allow you to repeat blocks of code multiple times, typically while changing the values of variables inside the repeating block. We will learn about conditionals, which allow you to execute different branches of code depending on the values of variables.\n\n\n\nLearning with Python 3 chapter 5: Conditionals\nLearning with Python 3 chapter 7: Iteration\nPython for Data Analysis chapter 3: Built-in Data Structures, Functions, and Files\nPython for Data Analysis chapter 4: NumPy Basics: Arrays and Vectorized Computation\nPython for Data Analysis chapter 5: Getting Started with pandas\nConditionals and recursion (you can ignore for now the section on recursion)\nControl Flow\n\n\n\n\nLoops are used when you have a chunk of code that you need to repeat over and over again, each time changing one (or more) parameters.\nThere are two kinds of loops: a for loop and a while loop. A for loop is used when you (or your code) know in advance of starting the loop, how many iterations to run through. A while loop is used when the number of iterations is not known in advance of starting the loop. You might use a for loop to load in a list of data files. You might use a while loop to iterate through an EEG waveform over samples (time) to search for the first value that exceeds some baseline threshold.\nHere is a simple example for the purposes of demonstration. Let’s say you want to load data from 5 files, named data1.txt, data2.txt, …, data5.txt. Let’s say each file contains a one-dimensional array of 10 values. Let’s say you want to take the average of each data file and then report the overall mean and overall variance of those values. Here’s one way to do it:\n\n\n\nd1 = load(\"data1.txt\")\nd1m = mean(d1)\nd2 = load(\"data2.txt\")\nd2m = mean(d2)\nd3 = load(\"data3.txt\")\nd3m = mean(d3)\nd4 = load(\"data4.txt\")\nd4m = mean(d4)\nd5 = load(\"data5.txt\")\nd5m = mean(d5)\n\n# report overall mean and overall variance of 5 data file means\nalldata = [d1m, d2m, d3m, d4m, d5m]\ndatamean = mean(alldata)\ndatavar = var(alldata)\nprint(f\"mean={datamean:.3f} and variance={datavar:.3f}\")\n\nYou can see that there is a lot of repetition in this code. What if we had to load data from 1000 data files? There would be a lot of copying and pasting of code chunks. This is error prone and inefficient. Instead let’s use a for loop. A for loop allows you to repeat a block of code some predetermined number of times, and includes a counter so that you know which iteration of the loop is currently running. Here is what the code above would look like if we used a for loop:\n\nnfiles = 1000\nalldata = np.zeros(1000)\nfor i in range(nfiles):\n    d = load(\"data\" + str(i) + \".txt\")\n    alldata[i] = mean(d)\ndatamean = mean(alldata)\ndatavar = var(alldata)\nprint(f\"mean={datamean:.3f} and variance={datavar:.3f}\")\n\nNow all we would need to change if we have 1000 data files (or one million) is the value of our variable nfiles=1000 or nfiles=1e6—nothing else in the code would have to change. This makes our code much more resilient against programming errors.\nYou can see a for loop begins with the keyword for followed by a name of a variable (your choice) that will keep track of which iteration of the loop is currently running. Then for word in followed by a list of values to be iterated through. Next is the block of code to be repeated. Note that in Python, blocks of code like this are denoted using indentation. Python is very fussy indeed about indentation.\n\nfor i in range(1,15,3):\n    print(f\"i={i}\")\n\ni=1\ni=4\ni=7\ni=10\ni=13\n\n\nFor loops are executed in a serial fashion, one repetition after another.\n\n\n\nThere is a second sort of loop called a while loop. This kind of loop is typically used when the number of iterations is not known in advance. A while loop keeps repeating until the value of a logical expression changes from TRUE to FALSE (changes from 1 to 0). As a little demo, here is an example of a while loop that prints out successive integers starting from 1, until they exceed a critical value, in this case 10:\n\ni = 1\nwhile (i &lt; 9):\n    print(f\"i={i}\")\n    i = i + 1\n\ni=1\ni=2\ni=3\ni=4\ni=5\ni=6\ni=7\ni=8\n\n\nThe expression that determines whether a while loop will continue repeating can be any valid Python expression that evaluates to a boolean (true or false).\nFor both for loops and while loops, there are two keywords to know about that can break you out of a loop (break) and can move you to the next iteration of the loop (continue). I tend not to use these, but some people find them useful."
  },
  {
    "objectID": "control_flow_and_complex_data_types.html#readings",
    "href": "control_flow_and_complex_data_types.html#readings",
    "title": "Control Flow & Complex data types",
    "section": "",
    "text": "Learning with Python 3 chapter 5: Conditionals\nLearning with Python 3 chapter 7: Iteration\nPython for Data Analysis chapter 3: Built-in Data Structures, Functions, and Files\nPython for Data Analysis chapter 4: NumPy Basics: Arrays and Vectorized Computation\nPython for Data Analysis chapter 5: Getting Started with pandas\nConditionals and recursion (you can ignore for now the section on recursion)\nControl Flow"
  },
  {
    "objectID": "control_flow_and_complex_data_types.html#loops",
    "href": "control_flow_and_complex_data_types.html#loops",
    "title": "Control Flow & Complex data types",
    "section": "",
    "text": "Loops are used when you have a chunk of code that you need to repeat over and over again, each time changing one (or more) parameters.\nThere are two kinds of loops: a for loop and a while loop. A for loop is used when you (or your code) know in advance of starting the loop, how many iterations to run through. A while loop is used when the number of iterations is not known in advance of starting the loop. You might use a for loop to load in a list of data files. You might use a while loop to iterate through an EEG waveform over samples (time) to search for the first value that exceeds some baseline threshold.\nHere is a simple example for the purposes of demonstration. Let’s say you want to load data from 5 files, named data1.txt, data2.txt, …, data5.txt. Let’s say each file contains a one-dimensional array of 10 values. Let’s say you want to take the average of each data file and then report the overall mean and overall variance of those values. Here’s one way to do it:\n\n\n\nd1 = load(\"data1.txt\")\nd1m = mean(d1)\nd2 = load(\"data2.txt\")\nd2m = mean(d2)\nd3 = load(\"data3.txt\")\nd3m = mean(d3)\nd4 = load(\"data4.txt\")\nd4m = mean(d4)\nd5 = load(\"data5.txt\")\nd5m = mean(d5)\n\n# report overall mean and overall variance of 5 data file means\nalldata = [d1m, d2m, d3m, d4m, d5m]\ndatamean = mean(alldata)\ndatavar = var(alldata)\nprint(f\"mean={datamean:.3f} and variance={datavar:.3f}\")\n\nYou can see that there is a lot of repetition in this code. What if we had to load data from 1000 data files? There would be a lot of copying and pasting of code chunks. This is error prone and inefficient. Instead let’s use a for loop. A for loop allows you to repeat a block of code some predetermined number of times, and includes a counter so that you know which iteration of the loop is currently running. Here is what the code above would look like if we used a for loop:\n\nnfiles = 1000\nalldata = np.zeros(1000)\nfor i in range(nfiles):\n    d = load(\"data\" + str(i) + \".txt\")\n    alldata[i] = mean(d)\ndatamean = mean(alldata)\ndatavar = var(alldata)\nprint(f\"mean={datamean:.3f} and variance={datavar:.3f}\")\n\nNow all we would need to change if we have 1000 data files (or one million) is the value of our variable nfiles=1000 or nfiles=1e6—nothing else in the code would have to change. This makes our code much more resilient against programming errors.\nYou can see a for loop begins with the keyword for followed by a name of a variable (your choice) that will keep track of which iteration of the loop is currently running. Then for word in followed by a list of values to be iterated through. Next is the block of code to be repeated. Note that in Python, blocks of code like this are denoted using indentation. Python is very fussy indeed about indentation.\n\nfor i in range(1,15,3):\n    print(f\"i={i}\")\n\ni=1\ni=4\ni=7\ni=10\ni=13\n\n\nFor loops are executed in a serial fashion, one repetition after another.\n\n\n\nThere is a second sort of loop called a while loop. This kind of loop is typically used when the number of iterations is not known in advance. A while loop keeps repeating until the value of a logical expression changes from TRUE to FALSE (changes from 1 to 0). As a little demo, here is an example of a while loop that prints out successive integers starting from 1, until they exceed a critical value, in this case 10:\n\ni = 1\nwhile (i &lt; 9):\n    print(f\"i={i}\")\n    i = i + 1\n\ni=1\ni=2\ni=3\ni=4\ni=5\ni=6\ni=7\ni=8\n\n\nThe expression that determines whether a while loop will continue repeating can be any valid Python expression that evaluates to a boolean (true or false).\nFor both for loops and while loops, there are two keywords to know about that can break you out of a loop (break) and can move you to the next iteration of the loop (continue). I tend not to use these, but some people find them useful."
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "Sample Code",
    "section": "",
    "text": "fizzbuzz.py\nis_it_prime.py"
  },
  {
    "objectID": "concepts.html",
    "href": "concepts.html",
    "title": "Concepts",
    "section": "",
    "text": "installing our development environment"
  },
  {
    "objectID": "concepts.html#week-1",
    "href": "concepts.html#week-1",
    "title": "Concepts",
    "section": "",
    "text": "installing our development environment"
  },
  {
    "objectID": "concepts.html#week-2",
    "href": "concepts.html#week-2",
    "title": "Concepts",
    "section": "Week 2",
    "text": "Week 2\n\nediting a .py Python program and executing it in the shell\nthe iPython REPL\nuv add ipython to install; and then uv run ipython to launch\nexpressions, operators, values, & variables\noperator precedence\nusing brackets ( and ) to override operator precedence\nnumeric vs character string data types\nvariables: str, int, float, bool, inspect using type()\nconversion: str(), int(), float()\noperators: + - * /, **, modulus %\nlogical operators &lt; &gt; == &gt;= &lt;= != and or not True False\nimport statements—for example, from math import cos\nprint() and formatted output using f-strings\ngetting input from the user using input()\ncommenting code using #\nreserved keywords in Python (e.g. for, return, etc)\ngetting help using help()\nVisual Studio Code"
  },
  {
    "objectID": "concepts.html#week-3",
    "href": "concepts.html#week-3",
    "title": "Concepts",
    "section": "Week 3",
    "text": "Week 3\n\nconditionals if elif else\nloops using while and for\nrange() versus list types\n\n“range objects are a specific type of sequence in Python, they behave similarly to lists or tuples but are immutable and lazy”\n\nthe FizzBuzz coding exercise\nzero-based indexing in Python\nputting it all together: testing primeness of integers"
  },
  {
    "objectID": "concepts.html#week-4",
    "href": "concepts.html#week-4",
    "title": "Concepts",
    "section": "Week 4",
    "text": "Week 4\n\nlists in Python\nlist comprehensions e.g. five_odd_numbers = [i for i in range(1,11,2)]\nin Python list variables are pointers\nb = a vs b = a.copy()\nb == a vs b is a\nother complex data types in Python: tuples, ranges, dictionaries, and sets\nwriting your own functions in Python\n\ndefining a function\nfunction header\ninput arguments\nthe work\nreturning output(s)\nvariable scope\nnamed inputs\ndefault values\n\nthe idea of modularity of code"
  },
  {
    "objectID": "concepts.html#week-5",
    "href": "concepts.html#week-5",
    "title": "Concepts",
    "section": "Week 5",
    "text": "Week 5\n\nNumPy arrays\ncreating arrays\nnp.zeros() and np.ones()\nshape of arrays using np.shape()\nmultidimensional arrays\nvectorized operations on arrays\nslicing & indexing into arrays\nfile input & output: low-level\n\nall files are binary, a series of 8-bit bytes\nASCII encoding (and utf-8 more modern version)\nusing hex editor to view a file as hexadecimal bytes\nPython defaults: 32-bit int, 64-bit float, 8-bit char\nlittle-endian vs big-endian byte ordering (sys.byteorder to check)\nusing numpy to read and write binary bytes by specifying dtype\n\nfile input & output: high-level using NumPy & pandas"
  },
  {
    "objectID": "digital_representation_of_data.html",
    "href": "digital_representation_of_data.html",
    "title": "Digital Representation of Data",
    "section": "",
    "text": "Learning with Python 3 chapter 1: The way of the program\nLearning with Python 3 chapter 2: Variables, expressions and statements\nPython for Data Analysis chapter 1: Preliminaries\nPython for Data Analysis chapter 2: Python Language Basics, iPython, and Jupyter Notebooks\n\n\n\n\nThe way of the program\nVariables, expressions, and statements\nPython Language Basics\nHolding a Program in One’s Head"
  },
  {
    "objectID": "digital_representation_of_data.html#high-level-vs-low-level-languages",
    "href": "digital_representation_of_data.html#high-level-vs-low-level-languages",
    "title": "Digital Representation of Data",
    "section": "High-level vs low-level languages",
    "text": "High-level vs low-level languages\nThe CPU (central processing unit) chip(s) that sit on the motherboard of your computer is the piece of hardware that actually executes instructions. A CPU only understands a relatively low-level language called machine code. Often machine code is generated automatically by translating code written in assembly language, which is a low-level programming language that has a relatively direcy relationship to machine code (but is more readable by a human). A utility program called an assembler is what translates assembly language code into machine code.\nIn this course we will be learning how to program in Python, which is a high-level programming language. The “high-level” refers to the fact that the language has a strong abstraction from the details of the computer (the details of the machine code). A “strong abstraction” means that one can operate using high-level instructions without having to worry about the low-level details of carrying out those instructions.\nAn analogy is motor skill learning. A high-level language for human action might be drive your car to the grocery store and buy apples. A low-level version of this might be something like: (1) walk to your car; (2) open the door; (3) start the ignition; (4) put the transmission into Drive; (5) step on the gas pedal, and so on. An even lower-level description might involve instructions like: (1) activate your gastrocnemius muscle until you feel 2 kg of pressure on the underside of your right foot, maintain this pressure for 2.7 seconds, then release (stepping on the gas pedal); (2) move your left and right eyeballs 27 degrees to the left (check for oncoming cars); (3) activate your pectoralis muscle on the right side of your chest and simultaneously squeeze the steering wheel with the fingers on your right hand (steer the car to the left); and so on.\nFor scientific programming, we would like to deal at the highest level we can, so that we can avoid worrying about the low-level details. We might for example want to plot a line in a Figure and colour it blue. We don’t want to have to program the low-level details of how each pixel on the screen is set, and how to generate each letter of the font that is used to specify the x-axis label.\nAs an example, here is a hello, world program written in a variety of languages, just to give you a sense of things. You can see the high-level languages like MATLAB, Python and R are extremely readable and understandable, even though you may not know anything about these languages (yet). The C code is less readable, there are lots of details one may not know about... and the assembly language example is a bit of a nightmare, obviously too low-level for our needs here.\nPython\nprint(\"hello, world\")\nMATLAB\ndisp('hello, world')\nR\ncat(\"hello, world\\n\")\nJavascript\ndocument.write(\"hello, world\");\nFortran\nprint *,\"hello, world\"\nC\n#include &lt;stdio.h&gt;\nint main (int argc, char *argv[]) {\n  printf(\"hello, world\\n\");\n  return 0;\n}\n8086 Assembly language\n; this example prints out  \"hello world!\" by writing directly to video memory.\n; first byte is ascii character, next is character attribute (8 bit value)\n; high 4 bits set background color and low 4 bits set foreground color.\n \norg 100h\n\n; set video mode    \nmov ax, 3     ; text mode 80x25, 16 colors, 8 pages (ah=0, al=3)\nint 10h       ; do it!\n\n; cancel blinking and enable all 16 colors:\nmov ax, 1003h\nmov bx, 0\nint 10h\n\n; set segment register:\nmov     ax, 0b800h\nmov     ds, ax\n\n; print \"hello world\"\n\nmov [02h], 'H'\nmov [04h], 'e'\nmov [06h], 'l'\nmov [08h], 'l'\nmov [0ah], 'o'\nmov [0ch], ','\nmov [0eh], 'W'\nmov [10h], 'o'\nmov [12h], 'r'\nmov [14h], 'l'\nmov [16h], 'd'\nmov [18h], '!'\n\n; color all characters:\nmov cx, 12  ; number of characters.\nmov di, 03h ; start from byte after 'h'\n\nc:  mov [di], 11101100b   ; light red(1100) on yellow(1110)\n    add di, 2 ; skip over next ascii code in vga memory.\n    loop c\n\n; wait for any key press:\nmov ah, 0\nint 16h\n\nret"
  },
  {
    "objectID": "digital_representation_of_data.html#interpreted-vs-compiled-languages",
    "href": "digital_representation_of_data.html#interpreted-vs-compiled-languages",
    "title": "Digital Representation of Data",
    "section": "Interpreted vs compiled languages",
    "text": "Interpreted vs compiled languages\nSome languages like C and Fortran are compiled languages, meaning that we write code in C or Fortran, and then to run the code (to have the computer execute those instructions) we first have to translate the code into machine code, and then run the machine code. The utility function that performs this translation (compilation) is called a compiler. In addition to simply translating a high-level language into machine code, modern compilers will also perform a number of optimizations to ensure that the resulting machine code runs fast, and uses little memory. Typically we write a program in C, then compile it, and if there are no errors, we then run it. We deal with the entire program as a whole. Compiled program tend to be fast since the entire program is compiled and optimized as a whole, into machine code, and then run on the CPU as a whole.\nOther languages, like MATLAB, Python and R, are interpreted languages, meaning that we write code which is then translated, command by command, into machine language instructions which are run one after another. This is done using a utility called an interpreter. We don’t have to compile the whole program all together in order to run it. Instead we can run it one instruction at a time. Typically we do this in an interactive programming environment where we can type in a command, and observe the result, and then type a next command, etc. This is known as the read-eval-print (REPL) loop. This is advantageous for scientific programming, where we typically spend a lot of time exploring our data in an interactive way. One can of course run a program such as this in a batch mode, all at once, without the interactive REPL environment... but this doesn’t change the fact that the translation to machine code still happens one line at a time, each in isolation. Interpreted languages tend to be slow, because every single command is taken in isolation, one after the other, and in real time translated into machine code which is then executed in a piecemeal fashion.\nFor interactive programming, when we are exploring our data, interpreted languages like MATLAB, Python and R shine. They may be slow but it (typically) doesn’t matter, because what’s many orders of magnitude slower, is the firing of the neurons in our brain as we consider the output of each command and decide what to do next, how to analyse our data differently, what to plot next, etc. For batch programming (for example fMRI processing pipelines, or electrophysiological recording signal processing, or numerical optimizations, or statistical bootstrapping operations), where we want to run a large set of instructions all at once, without looking at the result of each step along the way, compiled languages really shine. They are much faster than interpreted languages, often several orders of magnitude faster. It’s not unusual for even a simple program written in C to run 100x or even 1000x faster than the same program written in MATLAB, Python or R.\nA 1000x speedup may not be very important when the program runs in 5 seconds (versus 5 milliseconds) but when a program takes 60 seconds to run in MATLAB, Python, or R, for example, things can start to get problematic.\nImagine you write some code to read in data from one subject, process that data, and write the result to a file, and that operation takes 60 seconds. Is that so bad? Not if you only have to run it once. Now let’s imagine you have 15 subjects in your group. Now 60 seconds is 15 minutes. Now let’s say you have 4 groups. Now 15 minutes is one hour. You run your program, go have lunch, and come back an hour later and you find there was an error. You fix the error and re-run. Another hour. Even if you get it right, now imagine your supervisor asks you to re-run the analysis 5 different ways, varying some parameter of the analysis (maybe filtering the data at a different frequency, for example). Now you need 5 hours to see the result. It doesn’t take a huge amount of data to run into this sort of situation.\nNow imagine if you could program this data processing pipeline in C instead, and you could achieve a 500x speedup (not unusual), now those 5 hours turn into 36 seconds (you could run your analysis twice and it would still take less time than listening to Stairway to Heaven a dozen times). All of a sudden it’s the difference between an overnight operation and a 30 second operation. That makes a big difference to the kind of work you can do, and the kinds of questions you can pursue.\nPython (when using NumPy) and MATLAB is pretty good about using optimized, compiled subroutines for certain operations (e.g. matrix algebra), so in many cases the difference between Python/MATLAB and C performance isn’t as great as it is for others. Python has add-ons, for example Numba, that with some work, enables one to essentially compile parts of Python code. In practice this can be tricky though. MATLAB also has a toolbox (called the MATLAB Coder) that will allow you to generate C code from your MATLAB code, so in principle you can take slow MATLAB code and generate faster, compiled C code."
  },
  {
    "objectID": "digital_representation_of_data.html#readings-1",
    "href": "digital_representation_of_data.html#readings-1",
    "title": "Digital Representation of Data",
    "section": "Readings",
    "text": "Readings\n\nplay with the IEEE-754 Floating Point Converter (e.g. lookup the representation of 0.1, 0.2, and 0.3)"
  },
  {
    "objectID": "digital_representation_of_data.html#binary",
    "href": "digital_representation_of_data.html#binary",
    "title": "Digital Representation of Data",
    "section": "Binary",
    "text": "Binary\nInformation on a digital computer is stored in a binary format. Binary format represents information using a series of 0s and 1s. If there are n digits of a binary code, one can represent 2^{n} bits of information.\nSo for example the binary number denoted by:\n0001\nrepresents the number 1.\n0010\nThis is a 4-bit code since there are 4 binary digits. The full list of all values that can be represented using a 4-bit code are shown in the Table below:\n\n\nCode\nprint(\"Decimal Binary\")\nprint(\"------- -------\")\nfor n in range(16):\n    print(f\"{n:7d} {n:04b}\")\n\n\nDecimal Binary\n------- -------\n      0 0000\n      1 0001\n      2 0010\n      3 0011\n      4 0100\n      5 0101\n      6 0110\n      7 0111\n      8 1000\n      9 1001\n     10 1010\n     11 1011\n     12 1100\n     13 1101\n     14 1110\n     15 1111\n\n\nSo with a 4-bit binary code one can represent 2^{4} = 16 different values (0-15). Each additional bit doubles the number of values one can represent. So a 5-bit code enables us to represent 32 distinct values, a 6-bit code 64, a 7-bit code 128 and an 8-bit code 256 values (0-255).\nAnother piece of terminology: a given sequence of binary digits that forms the natural unit of data for a given processor (CPU) is called a word.\nHave a look at the ASCII table. The standard ASCII table represents 128 different characters and the extended ASCII codes enable another 128 for a total of 256 characters. How many binary bits are used for each?"
  },
  {
    "objectID": "digital_representation_of_data.html#hexadecimal",
    "href": "digital_representation_of_data.html#hexadecimal",
    "title": "Digital Representation of Data",
    "section": "Hexadecimal",
    "text": "Hexadecimal\nYou will also see in the ASCII table that it gives the decimal representation of each character but also the Hexadecimal and Octal representations. The hexadecimal system is a base-16 code and the octal system is a base-8 code. Hex values for a single hexadecimal digit can range over:\n0 1 2 3 4 5 6 7 8 9 a b c d e f\nIf we use a 2-digit hex code we can represent 16^{2} = 256 distinct values. In computer science, engineering and programming, a common practice is to represent successive 4-bit binary sequences using single-digit hex codes:\n\n\nCode\nprint(\"Dec Bin  Hex\")\nprint(\"--- ---- ---\")\nfor n in range(16):\n    print(f\"{n:3d} {n:04b} {n:x}\")\n\n\nDec Bin  Hex\n--- ---- ---\n  0 0000 0\n  1 0001 1\n  2 0010 2\n  3 0011 3\n  4 0100 4\n  5 0101 5\n  6 0110 6\n  7 0111 7\n  8 1000 8\n  9 1001 9\n 10 1010 a\n 11 1011 b\n 12 1100 c\n 13 1101 d\n 14 1110 e\n 15 1111 f\n\n\nIf we have 8-bit binary codes we would use successive hex digits to represent each 4-bit word of the 8-bit byte (another piece of lingo):\n\n\nCode\nprint(\"Dec Bin      Hex\")\nprint(\"--- -------- ---\")\nfor n in range(3):\n    print(f\"{n:3d} {n:08b} {n:x}\")\nprint(\"    ...     \")\nfor n in range(253,256,1):\n    print(f\"{n:3d} {n:08b} {n:x}\")\n\n\nDec Bin      Hex\n--- -------- ---\n  0 00000000 0\n  1 00000001 1\n  2 00000010 2\n    ...     \n253 11111101 fd\n254 11111110 fe\n255 11111111 ff\n\n\nThe left chunk of 4-bit binary digits (the left word) is represented in hex as a single hex digit (0-f) and the next chunk of 4-bit binary digits (the right word) is represented as another single hex digit (0-f).\nHex is typically used to represent bytes (8-bits long) because it is a more compact notation than using 8 binary digits (hex uses just 2 hex digits)."
  },
  {
    "objectID": "digital_representation_of_data.html#floating-point-values",
    "href": "digital_representation_of_data.html#floating-point-values",
    "title": "Digital Representation of Data",
    "section": "Floating point values",
    "text": "Floating point values\nThe material above talks about the decimal representation of bytes in terms of integer values (e.g. 0-255). Frequently however in science we want the ability to represent real numbers on a continuous scale, for example 3.14159, or 5.5, or 0.123, etc. For this, the convention is to use floating point representations of numbers.\nThe idea behind the floating point representation is that it allows us to represent an approximation of a real number in a way that allows for a large number of possible values. Floating point numbers are represented to a fixed number of significant digits (called a significand) and then this is scaled using a base raised to an exponent:\ns~\\mathrm{x}~b^{e}\nThis is related to something you may have come across in high-school science, namely scientific notation. In scientific notation, the base is 10 and so a real number like 123.4 is represented as 1.234~\\mathrm{x}~10^{2}.\nIn computers there are different conventions for different CPUs but there are standards, like the IEEE 754 floating-point standard. As an example, a so-called single-precision floating point format is represented in binary (using a base of 2) using 32 bits (4 bytes) and a /double precision/ floating point number is represented using 64 bits (8 bytes). In C you can find out how many bytes are used for various types using the sizeof() function:\n#include &lt;stdio.h&gt;\nint main(int argc, char *argv[]) {\n  printf(\"a single precision float uses %ld bytes\\n\", sizeof(float));\n  printf(\"a double precision float uses %ld bytes\\n\", sizeof(double));\n  return 0;\n}\nOn my macbook pro laptop this results in this output:\na single precision float uses 4 bytes\na double precision float uses 8 bytes\nAccording to the IEEE 754 standard, a single precision 32-bit binary floating point representation is composed of a 1-bit sign bit (signifying whether the number is positive or negative), an 8-bit exponent and a 23-bit significand. See the various wikipedia pages for full details.\n\nFloating point error\nThere is a key phrase in the description of floating point values above, which is that floating point representation allows us to store an approximation of a real number. If we attempt to represent a number that has more significant digits than can be store in a 32-bit floating point value, then we have to approximate that real number, typically by rounding off the digits that cannot fit in the 32 bits. This introduces rounding error.\nNow with 32 bits, or even 64-bits in the case of double precision floating point values, rounding error is likely to be relatively small. However it’s not zero, and depending on what your program is doing with these values, the rounding errors can accumulate (for example if you’re simulating a dynamical system over thousands of time steps, and at each time step there is a small rounding error).\nWe don’t need a fancy simulation however to see the results of floating point rounding error. Open up your favourite programming language (MATLAB, Python, R, C, etc) and type the following (adjust the syntax as needed for your language of choice):\n\n(0.1 + 0.2) == 0.3\n\nFalse\n\n\nHow could this return False when it ought to be true?\nWhat’s going on here? What’s happening is that these decimal numbers, 0.1, 0.2 and 0.3 are being represented by the computer in a binary floating-point format, that is, using a base 2 representation. The issue is that in base 2, the decimal number 0.1 cannot be represented precisely, no matter how many bits you use. Plug in the decimal number 0.1 into an online binary/decimal/hexadecimal converter (such as here) and you will see that the binary representation of 0.1 is an infinitely repeating sequence:\n0.000110011001100110011001100... (base 2)\nThis shouldn’t be an unfamiliar situation, if we remember that there are also real numbers that cannot be represented precisely in decimal format, either, because they involve an infintely repeating sequence. For example the real number \\frac{1}{3} when represented in decimal is:\n0.3333333333... (base 10)\nIf we try to represent \\frac{1}{3} using n decimal digits then we have to chop off the digits to the right that we cannot include, thereby rounding the number. We lose some amount of precision that depends on how many significant digits we retain in our representation.\nSo the same is true in binary. There are some real numbers that cannot be represented precisely in binary floating-point format.\nSee here for some examples of significant adverse events (i.e. disasters) cause by numerical errors.\nRounding can be used to your advantage, if you’re in the business of stealing from people (see salami slicing). In the 1980s movie Superman III, Richard Pryor’s character plays a “bumbling computer genius” who embezzles a ton of money by stealing a large number of fractions of cents (which in the movie are said to be lost anyway due to rounding) from his company’s payroll (YouTube clip here).\nThere is a comprehensive theoretical summary of these issues here: What Every Computer Scientist Should Know About Floating-Point Arithmetic.\nHere is a fantastic blog post that takes you through how floating-point numbers are represented:\nExposing Floating Point\nFinally here is a recent post by Julia Evans in which she discusses different Examples of floating point problems\nand another post by Julia Evans in which she goes through the actual floating-point arithmetic that underlies the 0.1 + 0.2 == 0.3 problem: Why does 0.1 + 0.2 = 0.30000000000000004?"
  },
  {
    "objectID": "digital_representation_of_data.html#integer-overflow",
    "href": "digital_representation_of_data.html#integer-overflow",
    "title": "Digital Representation of Data",
    "section": "Integer Overflow",
    "text": "Integer Overflow\nJust in case you thought that floating point values are the only source of problems, representing integer values also comes with the problem of integer overflow. This is when one attempts to represent an integer that is larger than possible given the number of bits available.\nSo for example if we were representing positive integers using only 16 bits, we would only be able to store 2^{16}=65536 distinct values. So if the first value is 0 then we are able to store positive integers up to 65535. If we attempt to add the value 1 to a variable that uses 16 bits and is currently storing the value 65535, the variable will “overflow”, probably back to zero, in this case.\nHere is a not-well-enough-known recent case of integer overflow error affecting Boeing’s new 787 “Dreamliner” aircraft:\nReboot Your Dreamliner Every 248 Days To Avoid Integer Overflow"
  },
  {
    "objectID": "digital_representation_of_data.html#floating-point-precision",
    "href": "digital_representation_of_data.html#floating-point-precision",
    "title": "Digital Representation of Data",
    "section": "Floating point precision",
    "text": "Floating point precision\nOne non-intuitive feature of floating point representations is that the precision varies with the magnitude of the number being represented. That is, the “next possible representable number” is a very small step away from the current number, when the number is relatively small… but it becomes very large indeed when the numbers are large, sitting far along the number line.\nIn Python the numpy package has a function called nextafter() that will report the next representable value from a given value towards a second value:\n\nimport numpy as np\nx = 1.234\nx2 = np.nextafter(x, +np.inf)\nprint(f\"smallest possible increment after {x} is\\n {x2-x:0.20f}\")\n\nsmallest possible increment after 1.234 is\n 0.00000000000000022204\n\n\nNow let’s try this with a larger number:\n\nimport numpy as np\nx = 1234567890.123\nx2 = np.nextafter(x, +np.inf)\nprint(f\"smallest possible increment after {x} is\\n {x2-x:0.20f}\")\n\nsmallest possible increment after 1234567890.123 is\n 0.00000023841857910156\n\n\nNow let’s try a much larger number:\n\nimport numpy as np\nx = 1.234 * 10**25\nx2 = np.nextafter(x, +np.inf)\nprint(f\"smallest possible increment after {x} is\\n {x2-x:0.1f}\")\n\nsmallest possible increment after 1.2340000000000001e+25 is\n 2147483648.0\n\n\nSo if x is 1.234 * 10**25 (admittedly a large number) then the next number that is possible to represent with floating point arithmetic is more than two billion! That’s a big “step” along the number line.\nThis is a consequence of the floating-point representation of numbers. If you are regularly dealing with very large numbers then you should be aware of this."
  },
  {
    "objectID": "digital_representation_of_data.html#size-of-python-built-in-types",
    "href": "digital_representation_of_data.html#size-of-python-built-in-types",
    "title": "Digital Representation of Data",
    "section": "Size of Python built-in types",
    "text": "Size of Python built-in types\nIn Python we can query the size (in bytes) of a given variable using the function getsizeof() which is part of the sys module:\n\nimport sys\n\na = int(12)\nprint(f\"the {type(a)} {a} uses {sys.getsizeof(a)} bytes\")\n\nb = 123.456\nprint(f\"the {type(b)} {b} uses {sys.getsizeof(b)} bytes\")\n\nthe &lt;class 'int'&gt; 12 uses 28 bytes\nthe &lt;class 'float'&gt; 123.456 uses 24 bytes\n\n\nIn Python (version 3 and above) integer variables start off using a certain number of bytes but if necessary they will expand.\n\na = 1234567890987654321234567891\nprint(f\"the {type(a)} {a} uses {sys.getsizeof(a)} bytes\")\n\nb = a * 10\nprint(f\"the {type(b)} {b} uses {sys.getsizeof(b)} bytes\")\n\nthe &lt;class 'int'&gt; 1234567890987654321234567891 uses 36 bytes\nthe &lt;class 'int'&gt; 12345678909876543212345678910 uses 40 bytes\n\n\nOf course there are limits governed for integers by the size of your system’s memory.\nIn the case of floating-point values, the limit of 64 bits for the IEEE double-precision floating point format:\n\nprint(sys.float_info.max)\n\n1.7976931348623157e+308"
  },
  {
    "objectID": "digital_representation_of_data.html#ascii",
    "href": "digital_representation_of_data.html#ascii",
    "title": "Digital Representation of Data",
    "section": "ASCII",
    "text": "ASCII\nASCII stands for American Standard Code for Information Interchange. ASCII codes delineate how text is represented in digital format for computers (as well as other communications equipment).\nASCII uses a 7-bit binary code to represent 128 specific characters of text. The first 32 codes (decimal 0 through 31) are non-printable codes like TAB, BEL (play a bell sound), CR (carriage return), etc. Decimal codes 32 through 47 are more typical text symbols like # and &. Decimal codes 48 through 57 are the numbers 0 through 9:\n\n\nCode\nprint(\"Dec Hex Oct Chr\")\nprint(\"--- --- --- ---\")\nfor n in range(48,58,1):\n    print(f\"{n:3d}  {n:x}  {n:o}   {chr(n)}\")\n\n\nDec Hex Oct Chr\n--- --- --- ---\n 48  30  60   0\n 49  31  61   1\n 50  32  62   2\n 51  33  63   3\n 52  34  64   4\n 53  35  65   5\n 54  36  66   6\n 55  37  67   7\n 56  38  70   8\n 57  39  71   9\n\n\nDecimal codes 65 through 90 are capital letters A through Z, and codes 97 through 122 are lowercase letters a through z:\n\n\nCode\nprint(\"Dec Hex Oct Chr      Dec Hex Oct Chr\")\nprint(\"--- --- --- ---      --- --- --- ---\")\nfor n in range(65,91,1):\n    print(f\"{n:3d}  {n:x} {n:o}   {chr(n)}      {n+32:3d}  {n+32:x} {n+32:o}   {chr(n+32)}\")\n\n\nDec Hex Oct Chr      Dec Hex Oct Chr\n--- --- --- ---      --- --- --- ---\n 65  41 101   A       97  61 141   a\n 66  42 102   B       98  62 142   b\n 67  43 103   C       99  63 143   c\n 68  44 104   D      100  64 144   d\n 69  45 105   E      101  65 145   e\n 70  46 106   F      102  66 146   f\n 71  47 107   G      103  67 147   g\n 72  48 110   H      104  68 150   h\n 73  49 111   I      105  69 151   i\n 74  4a 112   J      106  6a 152   j\n 75  4b 113   K      107  6b 153   k\n 76  4c 114   L      108  6c 154   l\n 77  4d 115   M      109  6d 155   m\n 78  4e 116   N      110  6e 156   n\n 79  4f 117   O      111  6f 157   o\n 80  50 120   P      112  70 160   p\n 81  51 121   Q      113  71 161   q\n 82  52 122   R      114  72 162   r\n 83  53 123   S      115  73 163   s\n 84  54 124   T      116  74 164   t\n 85  55 125   U      117  75 165   u\n 86  56 126   V      118  76 166   v\n 87  57 127   W      119  77 167   w\n 88  58 130   X      120  78 170   x\n 89  59 131   Y      121  79 171   y\n 90  5a 132   Z      122  7a 172   z\n\n\nFor a full description of the 7-bit ascii codes in their entirety, including the extended ASCII codes (where you will find things like ö and é), see this webpage:\nhttp://www.asciitable.com (ASCII Table and Extended ASCII Codes).\nIn Python you can find the ASCII integer value of a character using the ord() function. You can get the character value of an ASCII code using the chr() function.\n\nord('A')\n\n65\n\n\n\nchr(65)\n\n'A'\n\n\nYou can use your knowledge of ASCII codes to do clever things, like convert to and from uppercase and lowercase, given your knowledge that the difference (in decimal) between ASCII A and ASCII a is 32 (see the ASCII table above):\n\nchr(ord('A')+32)\n\n'a'\n\n\n\nchr(ord('a')-32)\n\n'A'\n\n\nOf course in Python there are more straightforward ways to convert between upper and lower case:\n\n'a'.upper()\n\n'A'\n\n\n\n'A'.lower()\n\n'a'"
  },
  {
    "objectID": "digital_representation_of_data.html#unicode",
    "href": "digital_representation_of_data.html#unicode",
    "title": "Digital Representation of Data",
    "section": "Unicode",
    "text": "Unicode\nThe ASCII codes only represent a limited number of characters that are useful mostly in the English language. Starting in the 1980s, Xerox, Apple, and others began work on a new variable-length encoding scheme that could represent a much larger number of characters that would be useful for the world’s languages (and now even for emoji). This is called Unicode and includes the most common standard on the web, UTF-8, which can encode more than a million different characters and symbols.\nHere is a website where you can view and search the Unicode character table.\nFor example, in Unicode the smiling face emoji 😀 is encoded using hexadecimal value 1F600:\n\nprint(f\"Unicode (hex) 1f600 is {chr(0x1f600)}\")\n\nUnicode (hex) 1f600 is 😀"
  },
  {
    "objectID": "fundamentals.html",
    "href": "fundamentals.html",
    "title": "Fundamentals",
    "section": "",
    "text": "Digital representation of data\nControl flow & Complex data types\nFunctions, File input & output"
  },
  {
    "objectID": "fundamentals.html#pauls-notes",
    "href": "fundamentals.html#pauls-notes",
    "title": "Fundamentals",
    "section": "",
    "text": "Digital representation of data\nControl flow & Complex data types\nFunctions, File input & output"
  },
  {
    "objectID": "fundamentals.html#python-fundamentals",
    "href": "fundamentals.html#python-fundamentals",
    "title": "Fundamentals",
    "section": "Python Fundamentals",
    "text": "Python Fundamentals\n\nLearning with Python 3 chapter 1: The way of the program\nLearning with Python 3 chapter 2: Variables, expressions and statements\nPython for Data Analysis chapter 1: Preliminaries\nPython for Data Analysis chapter 2: Python Language Basics, iPython, and Jupyter Notebooks\nNumPy: the absolute basics for beginners\nPython for Data Analysis chapter 4: NumPy Basics: Arrays and Vectorized Computation\na fun coding challenge: Advent of Code 2015, Day 6 (hint: use a 1000x1000 2D array)\n\n\nother useful readings\n\nThe way of the program\nVariables, expressions, and statements\nPython Language Basics\nFiles & the File System by Kieran Healy\nHow to Name Files video by Jenny Bryan\n\n\n\nConditionals, Iteration, & Control Flow\n\nLearning with Python 3 chapter 5: Conditionals\nLearning with Python 3 chapter 7: Iteration\nPython for Data Analysis chapter 3: Built-in Data Structures, Functions, and Files\nPython for Data Analysis chapter 4: NumPy Basics: Arrays and Vectorized Computation\nPython for Data Analysis chapter 5: Getting Started with pandas\nConditionals and recursion (you can ignore for now the section on recursion)\nControl Flow\n\n\n\nFile i/o\n\nNumPy reading & writing files\nNumPy data types\npandas IO tools\nPython reading and writing files\nPython for Data Analysis chapter 6: Data Loading, Storage, and File Formats"
  },
  {
    "objectID": "homeworks.html",
    "href": "homeworks.html",
    "title": "A Note about Homeworks",
    "section": "",
    "text": "The reason I assign homework to you each week is not because I want to see the code that you write.\nThe purpose of homework is for you to do the intellectual work required to write the code.\nIf you choose to use an AI tool (e.g. ChatGPT) to write your homework code then you will probably get a very good grade in this course but you will not have done the intellectual work.\nIn my experience (more than three decades in a university environment), reading other people’s code (or code that an AI tool wrote) is not a substitute for doing the intellectual work required to produce your own code.\nIt simply isn’t.\nIf you take this course, and you get a good grade, your supervisors / bosses / collaborators will expect you to have mastered the material and skills that are advertised in the (public) course outline, and that are reflected in the homework assignments that you hand in.\nYour grade in this course is not the goal. The intellectual work is the goal. If you don’t want to do the intellectual work, don’t take the course. It would be a waste of your time and mine.\nIf you are having difficulty with the work, come and see me or the TA, we will be absolutely pleased to help!\n—P"
  },
  {
    "objectID": "hw/hw02.html",
    "href": "hw/hw02.html",
    "title": "Homework 2",
    "section": "",
    "text": "Due: Jan 25 by 11:59 pm eastern standard time\nSubmit a single file called name_02.py to Brightspace/OWL where name is replaced with your last name, e.g. gribble_02.py\n\nWrite a Python program to complete the Nth Prime number exercise.\nMake sure it produces the correct output given the example inputs."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scientific Computing FW25 (Jan-Apr 2026)",
    "section": "",
    "text": "URL\n\n\nwww.gribblelab.org/9040\n\n\n\n\nInstructor\n\n\nPaul Gribble (pgribble at uwo dot ca)\n\n\n\n\nClasses\n\n\nMondays & Thursdays, 9:30 am - 11:00 am in WIRB 1110\n\n\n\n\nTA\n\n\nAnthony Cruz (acruz27 at uwo dot ca)"
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Scientific Computing FW25 (Jan-Apr 2026)",
    "section": "Schedule",
    "text": "Schedule\n\n\n\n\n\n\n\n\n\nDate\nTopic / Notes\nHomework\n\n\n\n\nJan 5/8\nIntro ; Setup ; Git ; uv\n-\n\n\nJan 12/15\nFundamentals (expressions & variables)\nHW01\n\n\nJan 19/22\nFundamentals (loops & conditionals)\nHW02\n\n\nJan 26/29\nFundamentals (data structures & functions)\nHW03\n\n\nFeb 2/5\nFundamentals (NumPy & Pandas)\nHW04\n\n\nFeb 9/12\nObject Oriented Programming (OOP)\nHW05\n\n\nFeb 16/19\nno class (reading week)\n-\n\n\nFeb 23/26\nGraphical Displays of Data\nHW06\n\n\nMar 2/5\nReproducibility & Replicability\nHW07\n\n\nMar 9/12\nno class (Paul away)\n-\n\n\nMar 16/19\nSampling, Signal Processing, & Filtering Data\nHW08\n\n\nMar 23/26\nStatistical Thinking & Inferential Statistical Tests\nHW09\n\n\nMar 30/Apr 2\nFitting Models to Data\nHW10\n\n\nApr 6/Apr 9\nSimulating Dynamical Systems\n-\n\n\n\n\n\n\nconcepts covered each week\nsample code produced in class"
  },
  {
    "objectID": "index.html#readings",
    "href": "index.html#readings",
    "title": "Scientific Computing FW25 (Jan-Apr 2026)",
    "section": "Readings",
    "text": "Readings\n\nBetter Code, Better Science by Russ Poldrack\nThe Curious Coder’s Guide to Git by Matthew Brett"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Set Up Your Computer",
    "section": "",
    "text": "Yes.\nSort of.\nFor this course, we will be working extensively with the command line and VS Code, which function similarly across all three major operating system, so you can use whichever OS you prefer or already have. Linux is the gold standard in scientific computing environments; most computing clusters, cloud servers, and neuroimaging pipelines run on it, so familiarity with its command line is invaluable. MacOS runs on a Unix variant under the hood, meaning the terminal experience is nearly identical, making it a convenient choice for researchers who want a polished laptop environment that translates well to work on Linux/Unix environments such as servers and clusters.\nWindows has historically been the odd one out for scientific computing, but the Windows Subsystem for Linux (WSL) has changed this dramatically. The WSL lets you run a full Linux environment inside Windows, giving you access to the same tools and workflows. For our purposes, the key is having a working terminal and Python environment.\nSo if you are already using Unix/Linux, good news, you are all set, just some configuration things and some package installs and your computing environment will be ready for a modern course in coding / scientific computing.\nIf you are using MacOS, also good news, you may not know it but MacOS is based on a Unix variant, so with some small configuration things and some package installs, you will also be ready.\nIf you are using Windows, it will be ok. Something we will cover in this course is learning to use the terminal, learning about file systems, files, directories, and so on. On Linux/Unix and on MacOS (which is based on Unix) this is straightforward and you won’t need to do anything particularly special. On Windows however you will need to do some initial setup to install something called the Windows Subsystem for Linux (WSL). This will enable you to launch a Linux session within Windows, and follow along in the course with everyone else. It’s not such a big deal. Instructions are below.\nPS: Personally I am most familiar with MacOS and Unix/Linux. I am quite unfamiliar with Windows.\n\n\nOpen up an Ubuntu terminal and (assuming Ubuntu Linux) update the system:\nsudo apt update\nsudo apt upgrade -y\nand then install some necessary tools including git:\nsudo apt install -y build-essential git curl\nand then install the uv tool:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nclose your Terminal.\nand then download Visual Studio Code and install it.\n\n\n\nOpen up a terminal and install some necessary build tools:\nxcode-select --install\nInstall the Homebrew package manager:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nThen close the terminal and open up a new one, and install some other necessary tools including git:\nbrew install git\nThen install the uv tool:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nclose your Terminal.\nand then download Visual Studio Code and install it.\nIf you want a nicer looking Terminal than the one that ships with MacOS you can try one of these:\n\niTerm2\nghostty\n\n\n\n\nFirst update Windows, I think you can access this by going to the Start menu and typing “update” and one of the options will be a system update.\nNext, open up Powershell (again, go to the Start menu and type Powershell to access it) and type:\nwsl --install\nWhen it is done, reboot your computer.\nOpen up Powershell again and type:\nwsl.exe --install Ubuntu\nIt will eventually ask you for a default Unix user account and password.\nClose Powershell and any other junky windows that Windows may have opened.\nOpen Powershell and check to see which version of WSL is running:\nwsl -l -v\nif it shows version 1 instead of version 2 then switch:\nwsl --set-version Ubuntu 2\nClose Powershell and reboot the computer.\nFrom your Start menu select “Ubuntu” and it should launch a terminal, which is now, running Ubuntu linux.\nNow go through the steps above in the Unix/Linux section."
  },
  {
    "objectID": "setup.html#macos-windows-or-linux",
    "href": "setup.html#macos-windows-or-linux",
    "title": "Set Up Your Computer",
    "section": "",
    "text": "Yes.\nSort of.\nFor this course, we will be working extensively with the command line and VS Code, which function similarly across all three major operating system, so you can use whichever OS you prefer or already have. Linux is the gold standard in scientific computing environments; most computing clusters, cloud servers, and neuroimaging pipelines run on it, so familiarity with its command line is invaluable. MacOS runs on a Unix variant under the hood, meaning the terminal experience is nearly identical, making it a convenient choice for researchers who want a polished laptop environment that translates well to work on Linux/Unix environments such as servers and clusters.\nWindows has historically been the odd one out for scientific computing, but the Windows Subsystem for Linux (WSL) has changed this dramatically. The WSL lets you run a full Linux environment inside Windows, giving you access to the same tools and workflows. For our purposes, the key is having a working terminal and Python environment.\nSo if you are already using Unix/Linux, good news, you are all set, just some configuration things and some package installs and your computing environment will be ready for a modern course in coding / scientific computing.\nIf you are using MacOS, also good news, you may not know it but MacOS is based on a Unix variant, so with some small configuration things and some package installs, you will also be ready.\nIf you are using Windows, it will be ok. Something we will cover in this course is learning to use the terminal, learning about file systems, files, directories, and so on. On Linux/Unix and on MacOS (which is based on Unix) this is straightforward and you won’t need to do anything particularly special. On Windows however you will need to do some initial setup to install something called the Windows Subsystem for Linux (WSL). This will enable you to launch a Linux session within Windows, and follow along in the course with everyone else. It’s not such a big deal. Instructions are below.\nPS: Personally I am most familiar with MacOS and Unix/Linux. I am quite unfamiliar with Windows.\n\n\nOpen up an Ubuntu terminal and (assuming Ubuntu Linux) update the system:\nsudo apt update\nsudo apt upgrade -y\nand then install some necessary tools including git:\nsudo apt install -y build-essential git curl\nand then install the uv tool:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nclose your Terminal.\nand then download Visual Studio Code and install it.\n\n\n\nOpen up a terminal and install some necessary build tools:\nxcode-select --install\nInstall the Homebrew package manager:\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nThen close the terminal and open up a new one, and install some other necessary tools including git:\nbrew install git\nThen install the uv tool:\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nclose your Terminal.\nand then download Visual Studio Code and install it.\nIf you want a nicer looking Terminal than the one that ships with MacOS you can try one of these:\n\niTerm2\nghostty\n\n\n\n\nFirst update Windows, I think you can access this by going to the Start menu and typing “update” and one of the options will be a system update.\nNext, open up Powershell (again, go to the Start menu and type Powershell to access it) and type:\nwsl --install\nWhen it is done, reboot your computer.\nOpen up Powershell again and type:\nwsl.exe --install Ubuntu\nIt will eventually ask you for a default Unix user account and password.\nClose Powershell and any other junky windows that Windows may have opened.\nOpen Powershell and check to see which version of WSL is running:\nwsl -l -v\nif it shows version 1 instead of version 2 then switch:\nwsl --set-version Ubuntu 2\nClose Powershell and reboot the computer.\nFrom your Start menu select “Ubuntu” and it should launch a terminal, which is now, running Ubuntu linux.\nNow go through the steps above in the Unix/Linux section."
  },
  {
    "objectID": "setup.html#check-your-setup",
    "href": "setup.html#check-your-setup",
    "title": "Set Up Your Computer",
    "section": "Check your setup",
    "text": "Check your setup\nCreate a new folder somewhere on your computer’s file system and name it Psych_9040, and then navigate inside of it.\nOpen Ubuntu:\nmkdir Psych_9040\ncd Psych_9040\nUse uv to install a python environment\nuv init --python 3.12\nAdd the numpy package\nuv add numpy\nCreate a new empty file:\ntouch hello.py\nand add some Python lines of code to it:\necho \"import numpy as np\" &gt;&gt; hello.py\necho \"x = np.array ([2, 3, 5, 7, 11, 13, 17, 19, 23, 29])\" &gt;&gt; hello.py\necho \"y = np.sum(x)\" &gt;&gt; hello.py\necho \"print(f\\\"the sum of {x} is {y}\\\")\" &gt;&gt; hello.py\nand test the code:\nuv run python hello.py\nand you should see this output:\nthe sum of [ 2  3  5  7 11 13 17 19 23 29] is 129"
  },
  {
    "objectID": "setup.html#gitgithub",
    "href": "setup.html#gitgithub",
    "title": "Set Up Your Computer",
    "section": "Git/GitHub",
    "text": "Git/GitHub\nWe will be learning about and using code versioning with Git and GitHub, so you should sign up for a (free) GitHub account."
  },
  {
    "objectID": "setup.html#visual-studio-code",
    "href": "setup.html#visual-studio-code",
    "title": "Set Up Your Computer",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nAfter installing VS Code, launch it, and enable launching from the terminal.\n\nMacOS\n\nOpen VS Code: Launch the Visual Studio Code application.\nInstall Shell Command by Open the Command Palette by pressing Shift + Command + P (or F1).\nType “shell command” into the prompt.\nSelect the command “Shell Command: Install ‘code’ command in PATH”. (You might be prompted for your administrator password.)\nLaunch from Terminal: Open your terminal. Navigate to the directory of your project. Type the following command:\n\ncode .\nThe . opens the current directory in a new VS Code window. You can replace . with a specific file name or directory path.\n\n\nWSL on Windows\n\nLaunch VS Code in your Windows environment.\nOpen the Command Palette (Ctrl + Shift + P).\nType “shell command” and select “Shell Command: Install ‘code’ command in PATH” if you didn’t do so during the initial installation of the Remote - WSL extension. The extension should typically handle this installation, but verifying doesn’t hurt.\nLaunch from WSL Terminal: Open your WSL terminal (e.g., Ubuntu). Navigate to your project directory within the Linux environment. Type the command:\n\ncode .\nThis command will open the current Linux directory in a new VS Code window on your Windows desktop, automatically connecting via the Remote - WSL extension."
  }
]