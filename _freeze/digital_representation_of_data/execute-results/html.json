{
  "hash": "a7b79d3e433fed8ce4902c965c8b343c",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Digital Representation of Data\"\nformat:\n  html:\n    toc: true\n---\n\n# Readings\n\n- Learning with Python 3 chapter 1: [The way of the program](https://openbookproject.net/thinkcs/python/english3e/way_of_the_program.html)\n- Learning with Python 3 chapter 2: [Variables, expressions and statements](https://openbookproject.net/thinkcs/python/english3e/variables_expressions_statements.html)\n- Python for Data Analysis chapter 1: [Preliminaries](https://wesmckinney.com/book/preliminaries.html)\n- Python for Data Analysis chapter 2: [Python Language Basics, iPython, and Jupyter Notebooks](https://wesmckinney.com/book/python-basics.html)\n\n### other potentially useful readings\n\n- [The way of the program](https://openbookproject.net/thinkcs/python/english3e/way_of_the_program.html)\n- [Variables, expressions, and statements](https://greenteapress.com/thinkpython2/html/thinkpython2003.html)\n- [Python Language Basics](https://wesmckinney.com/book/python-basics.html#tut_basics)\n- [Holding a Program in One's Head](http://www.paulgraham.com/head.html)\n\n# What is a Computer Program?\n\nWhat is a computer program? What is code? What is a computer language? A computer program is simply a series of instructions that the computer executes, one after the other. An instruction is a single command. A program is a series of instructions. Code is another way of referring to a single instruction or a series of instructions (a program).\n\n## High-level vs low-level languages\n\nThe [CPU](https://en.wikipedia.org/wiki/Central_processing_unit) (central processing unit) chip(s) that sit on the [motherboard](https://en.wikipedia.org/wiki/Motherboard) of your computer is the piece of hardware that actually executes instructions. A CPU only understands a relatively low-level language called [machine code](https://en.wikipedia.org/wiki/Machine_code). Often machine code is generated automatically by translating code written in [assembly language](https://en.wikipedia.org/wiki/Assembly_language), which is a [low-level programming language](https://en.wikipedia.org/wiki/Low-level_programming_language) that has a relatively direcy relationship to machine code (but is more readable by a human). A utility program called an [assembler](https://en.wikipedia.org/wiki/Assembly_language#Assembler) is what translates assembly language code into machine code.\n\nIn this course we will be learning how to program in Python, which is a [high-level programming language](https://en.wikipedia.org/wiki/High-level_programming_language). The \"high-level\" refers to the fact that the language has a strong abstraction from the details of the computer (the details of the machine code). A \"strong abstraction\" means that one can operate using high-level instructions without having to worry about the low-level details of carrying out those instructions.\n\nAn analogy is motor skill learning. A high-level language for human action might be *drive your car to the grocery store and buy apples*. A low-level version of this might be something like: (1) walk to your car; (2) open the door; (3) start the ignition; (4) put the transmission into Drive; (5) step on the gas pedal, and so on. An even lower-level description might involve instructions like: (1) activate your\n[gastrocnemius muscle](https://en.wikipedia.org/wiki/Gastrocnemius_muscle) until you feel 2 kg of pressure on the underside of your right foot, maintain this pressure for 2.7 seconds, then release (stepping on the gas pedal); (2) move your left and right eyeballs 27 degrees to the left (check for oncoming cars); (3) activate your pectoralis muscle on the right side of your chest and simultaneously squeeze the steering wheel with the fingers on your right hand (steer the car to the left); and so on.\n\nFor scientific programming, we would like to deal at the highest level we can, so that we can avoid worrying about the low-level details. We might for example want to plot a line in a Figure and colour it blue. We don't want to have to program the low-level details of how each pixel on the screen is set, and how to generate each letter of the font that is used to specify the x-axis label.\n\nAs an example, here is a *hello, world* program written in a variety of languages, just to give you a sense of things. You can see the high-level languages like MATLAB, Python and R are extremely readable and understandable, even though you may not know anything about these languages (yet). The C code is less readable, there are lots of details one may not know about\\... and the assembly language example is a bit of a nightmare, obviously too low-level for our needs here.\n\nPython\n\n``` python\nprint(\"hello, world\")\n```\n\nMATLAB\n``` matlab\ndisp('hello, world')\n```\n\nR\n\n```r\ncat(\"hello, world\\n\")\n```\n\nJavascript\n\n```javascript\ndocument.write(\"hello, world\");\n```\n\nFortran\n\n```fortran\nprint *,\"hello, world\"\n```\n\nC\n\n``` c\n#include <stdio.h>\nint main (int argc, char *argv[]) {\n  printf(\"hello, world\\n\");\n  return 0;\n}\n```\n\n8086 Assembly language\n\n```asm\n; this example prints out  \"hello world!\" by writing directly to video memory.\n; first byte is ascii character, next is character attribute (8 bit value)\n; high 4 bits set background color and low 4 bits set foreground color.\n \norg 100h\n\n; set video mode    \nmov ax, 3     ; text mode 80x25, 16 colors, 8 pages (ah=0, al=3)\nint 10h       ; do it!\n\n; cancel blinking and enable all 16 colors:\nmov ax, 1003h\nmov bx, 0\nint 10h\n\n; set segment register:\nmov     ax, 0b800h\nmov     ds, ax\n\n; print \"hello world\"\n\nmov [02h], 'H'\nmov [04h], 'e'\nmov [06h], 'l'\nmov [08h], 'l'\nmov [0ah], 'o'\nmov [0ch], ','\nmov [0eh], 'W'\nmov [10h], 'o'\nmov [12h], 'r'\nmov [14h], 'l'\nmov [16h], 'd'\nmov [18h], '!'\n\n; color all characters:\nmov cx, 12  ; number of characters.\nmov di, 03h ; start from byte after 'h'\n\nc:  mov [di], 11101100b   ; light red(1100) on yellow(1110)\n    add di, 2 ; skip over next ascii code in vga memory.\n    loop c\n\n; wait for any key press:\nmov ah, 0\nint 16h\n\nret\n```\n\n## Interpreted vs compiled languages\n\nSome languages like C and Fortran are [compiled languages](https://en.wikipedia.org/wiki/Compiled_language), meaning that we write code in C or Fortran, and then to run the code (to have the computer execute those instructions) we first have to translate the code into machine code, and then run the machine code. The utility function that performs this translation (compilation) is called a [compiler](https://en.wikipedia.org/wiki/Compiler). In addition to simply translating a high-level language into machine code, modern compilers will also perform a number of optimizations to ensure that the resulting machine code runs fast, and uses little memory. Typically we write a program in C, then compile it, and if there are no errors, we then run it. We deal with the entire program as a whole. Compiled program tend to be fast since the entire program is compiled and optimized as a whole, into machine code, and then run on the CPU as a whole.\n\nOther languages, like MATLAB, Python and R, are [interpreted languages](https://en.wikipedia.org/wiki/Interpreted_language), meaning that we write code which is then translated, command by command, into machine language instructions which are run one after another. This is done using a utility called an [interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing)). We don't have to compile the whole program all together in order to run it. Instead we can run it one instruction at a time. Typically we do this in an interactive programming environment where we can type in a command, and observe the result, and then type a next command, etc. This is known as the [read-eval-print (REPL) loop](https://en.wikipedia.org/wiki/Readâ€“evalâ€“print_loop). This is advantageous for scientific programming, where we typically spend a lot of time exploring our data in an interactive way. One can of course run a program such as this in a batch mode, all at once, without the interactive REPL environment\\... but this doesn't change the fact that the translation to machine code still happens one line at a time, each in isolation. Interpreted languages tend to be slow, because every single command is taken in isolation, one after the other, and in real time translated into machine code which is then executed in a piecemeal fashion.\n\nFor interactive programming, when we are exploring our data, interpreted languages like MATLAB, Python and R shine. They may be slow but it (typically) doesn't matter, because what's many orders of magnitude slower, is the firing of the neurons in our brain as we consider the output of each command and decide what to do next, how to analyse our data differently, what to plot next, etc. For batch programming (for example fMRI processing pipelines, or electrophysiological recording signal processing, or numerical optimizations, or statistical bootstrapping operations), where we want to run a large set of instructions all at once, without looking at the result of each step along the way, compiled languages really shine. They are much faster than interpreted languages, often several orders of magnitude faster. It's not unusual for even a simple program written in C to run 100x or even 1000x faster than the same program written in MATLAB, Python or R.\n\nA 1000x speedup may not be very important when the program runs in 5 seconds (versus 5 milliseconds) but when a program takes 60 seconds to run in MATLAB, Python, or R, for example, things can start to get problematic.\n\nImagine you write some code to read in data from one subject, process that data, and write the result to a file, and that operation takes 60 seconds. Is that so bad? Not if you only have to run it once. Now let's imagine you have 15 subjects in your group. Now 60 seconds is 15 minutes. Now let's say you have 4 groups. Now 15 minutes is one hour. You run your program, go have lunch, and come back an hour later and you find there was an error. You fix the error and re-run. Another hour. Even if you get it right, now imagine your supervisor asks you to re-run the analysis 5 different ways, varying some parameter of the analysis (maybe filtering the data at a different frequency, for example). Now you need 5 hours to see the result. It doesn't take a huge amount of data to run into this sort of situation.\n\nNow imagine if you could program this data processing pipeline in C instead, and you could achieve a 500x speedup (not unusual), now those 5 hours turn into 36 seconds (you could run your analysis twice and it would still take less time than listening to Stairway to Heaven a dozen times). All of a sudden it's the difference between an overnight operation and a 30 second operation. That makes a big difference to the kind of work you can do, and the kinds of questions you can pursue.\n\nPython (when using NumPy) and MATLAB is pretty good about using optimized, compiled subroutines for certain operations (e.g. matrix algebra), so in many cases the difference between Python/MATLAB and C performance isn't as great as it is for others. Python has add-ons, for example [Numba](https://numba.pydata.org), that with some work, enables one to essentially compile parts of Python code. In practice this can be tricky though. MATLAB also has a toolbox (called the [MATLAB Coder](http://www.mathworks.com/products/matlab-coder/)) that will allow you to generate C code from your MATLAB code, so in principle you can take slow MATLAB code and generate faster, compiled C code. \n\n\n# Digital Representation of Data\n\nHere we review how information is stored in digital format on computers.\n\nYou will see some Python code used here to illustrate concepts. It is not necessary to understand the Python code to understand the concepts. We will be going over Python programming in subsequent classes.\n\n## Readings\n\n- play with the [IEEE-754 Floating Point Converter](https://www.h-schmidt.net/FloatConverter/IEEE754.html) (e.g. lookup the representation of 0.1, 0.2, and 0.3)\n\n## Binary\n\nInformation on a digital computer is stored in a [binary](http://en.wikipedia.org/wiki/Binary_code) format. Binary format represents information using a series of 0s and 1s. If there are $n$ digits of a binary code, one can represent $2^{n}$ [bits](http://en.wikipedia.org/wiki/Bit) of information.\n\nSo for example the binary number denoted by:\n\n```\n0001\n```\n\nrepresents the number 1.\n\n```\n0010\n```\n\nThis is a 4-bit code since there are 4 binary digits. The full list of all values that can be represented using a 4-bit code are shown in the Table below:\n\n::: {#e108b296 .cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"Decimal Binary\")\nprint(\"------- -------\")\nfor n in range(16):\n    print(f\"{n:7d} {n:04b}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDecimal Binary\n------- -------\n      0 0000\n      1 0001\n      2 0010\n      3 0011\n      4 0100\n      5 0101\n      6 0110\n      7 0111\n      8 1000\n      9 1001\n     10 1010\n     11 1011\n     12 1100\n     13 1101\n     14 1110\n     15 1111\n```\n:::\n:::\n\n\nSo with a 4-bit binary code one can represent $2^{4} = 16$ different values (0-15). Each additional bit doubles the number of values one can represent. So a 5-bit code enables us to represent 32 distinct values, a 6-bit code 64, a 7-bit code 128 and an 8-bit code 256 values (0-255).\n\nAnother piece of terminology: a given sequence of binary digits that forms the natural unit of data for a given processor (CPU) is called a [word](http://en.wikipedia.org/wiki/Word_(computer_architecture)).\n\nHave a look at the [ASCII table](http://www.asciitable.com). The standard ASCII table represents 128 different characters and the extended ASCII codes enable another 128 for a total of 256 characters. How many binary bits are used for each?\n\n## Hexadecimal\n\nYou will also see in the ASCII table that it gives the decimal representation of each character but also the Hexadecimal and Octal representations. The [hexadecimal](http://en.wikipedia.org/wiki/Hexadecimal) system is a base-16 code and the [octal](http://en.wikipedia.org/wiki/Octal) system is a base-8 code. Hex values for a single hexadecimal digit can range over:\n\n```\n0 1 2 3 4 5 6 7 8 9 a b c d e f\n```\n\nIf we use a 2-digit hex code we can represent $16^{2} = 256$ distinct values. In computer science, engineering and programming, a common practice is to represent successive 4-bit binary sequences using single-digit hex codes:\n\n::: {#9aedda8c .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"Dec Bin  Hex\")\nprint(\"--- ---- ---\")\nfor n in range(16):\n    print(f\"{n:3d} {n:04b} {n:x}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDec Bin  Hex\n--- ---- ---\n  0 0000 0\n  1 0001 1\n  2 0010 2\n  3 0011 3\n  4 0100 4\n  5 0101 5\n  6 0110 6\n  7 0111 7\n  8 1000 8\n  9 1001 9\n 10 1010 a\n 11 1011 b\n 12 1100 c\n 13 1101 d\n 14 1110 e\n 15 1111 f\n```\n:::\n:::\n\n\nIf we have 8-bit binary codes we would use successive hex digits to represent each 4-bit word of the 8-bit [byte](http://en.wikipedia.org/wiki/Byte) (another piece of lingo):\n\n::: {#833799ad .cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"Dec Bin      Hex\")\nprint(\"--- -------- ---\")\nfor n in range(3):\n    print(f\"{n:3d} {n:08b} {n:x}\")\nprint(\"    ...     \")\nfor n in range(253,256,1):\n    print(f\"{n:3d} {n:08b} {n:x}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDec Bin      Hex\n--- -------- ---\n  0 00000000 0\n  1 00000001 1\n  2 00000010 2\n    ...     \n253 11111101 fd\n254 11111110 fe\n255 11111111 ff\n```\n:::\n:::\n\n\nThe left chunk of 4-bit binary digits (the left word) is represented in hex as a single hex digit (0-f) and the next chunk of 4-bit binary digits (the right word) is represented as another single hex digit (0-f).\n\nHex is typically used to represent bytes (8-bits long) because it is a more compact notation than using 8 binary digits (hex uses just 2 hex digits).\n\n## Floating point values\n\nThe material above talks about the decimal representation of bytes in terms of integer values (e.g. 0-255). Frequently however in science we want the ability to represent [real numbers](http://en.wikipedia.org/wiki/Real_number) on a continuous scale, for example 3.14159, or 5.5, or 0.123, etc. For this, the convention is to use [floating point](http://en.wikipedia.org/wiki/Floating_point) representations of numbers.\n\nThe idea behind the floating point representation is that it allows us to represent an approximation of a real number in a way that allows for a large number of possible values. Floating point numbers are represented to a fixed number of *significant digits* (called a *significand*) and then this is scaled using a *base* raised to an *exponent*:\n\n$$s~\\mathrm{x}~b^{e}$$\n\nThis is related to something you may have come across in high-school science, namely [scientific\nnotation](http://en.wikipedia.org/wiki/Scientific_notation). In scientific notation, the base is 10 and so a real number like 123.4 is represented as $1.234~\\mathrm{x}~10^{2}$.\n\nIn computers there are different conventions for different CPUs but there are standards, like the [IEEE\n754](http://en.wikipedia.org/wiki/IEEE_floating_point) floating-point standard. As an example, a so-called [single-precision floating point format](http://en.wikipedia.org/wiki/Binary32) is represented in binary (using a base of 2) using 32 bits (4 bytes) and a /double precision/ floating point number is represented using 64 bits (8 bytes). In C you can find out how many bytes are used for various types using the `sizeof()` function:\n\n``` c\n#include <stdio.h>\nint main(int argc, char *argv[]) {\n  printf(\"a single precision float uses %ld bytes\\n\", sizeof(float));\n  printf(\"a double precision float uses %ld bytes\\n\", sizeof(double));\n  return 0;\n}\n```\n\nOn my macbook pro laptop this results in this output:\n\n```\na single precision float uses 4 bytes\na double precision float uses 8 bytes\n```\n\nAccording to the IEEE 754 standard, a single precision 32-bit binary floating point representation is composed of a *1-bit sign bit* (signifying whether the number is positive or negative), an *8-bit exponent* and a *23-bit significand*. See the various wikipedia pages for full details.\n\n### Floating point error\n\nThere is a key phrase in the description of floating point values above, which is that floating point representation allows us to store an *approximation* of a real number. If we attempt to represent a number\nthat has more significant digits than can be store in a 32-bit floating point value, then we have to approximate that real number, typically by rounding off the digits that cannot fit in the 32 bits. This introduces [rounding error](http://en.wikipedia.org/wiki/Round-off_error).\n\nNow with 32 bits, or even 64-bits in the case of double precision floating point values, rounding error is likely to be relatively small. However it's not zero, and depending on what your program is doing with these values, the rounding errors can accumulate (for example if you're simulating a dynamical system over thousands of time steps, and at each time step there is a small rounding error).\n\nWe don't need a fancy simulation however to see the results of floating point rounding error. Open up your favourite programming language (MATLAB, Python, R, C, etc) and type the following (adjust the syntax as needed for your language of choice):\n\n::: {#15af1477 .cell execution_count=4}\n``` {.python .cell-code}\n(0.1 + 0.2) == 0.3\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nFalse\n```\n:::\n:::\n\n\nHow could this return `False` when it ought to be true?\n\nWhat's going on here? What's happening is that these decimal numbers, 0.1, 0.2 and 0.3 are being represented by the computer in a binary floating-point format, that is, using a base 2 representation. The issue is that in base 2, the decimal number 0.1 cannot be represented precisely, no matter how many bits you use. Plug in the decimal number 0.1 into an online binary/decimal/hexadecimal converter (such as [here](http://www.wolframalpha.com/input/?i=0.1+to+binary)) and you will see that the binary representation of 0.1 is an infinitely repeating sequence:\n\n```\n0.000110011001100110011001100... (base 2)\n```\n\nThis shouldn't be an unfamiliar situation, if we remember that there are also real numbers that cannot be represented precisely in decimal format, either, because they involve an infintely repeating sequence. For example the real number $\\frac{1}{3}$ [when represented in decimal](http://www.wolframalpha.com/input/?i=1%2F3+in+decimal) is:\n\n```\n0.3333333333... (base 10)\n```\n\nIf we try to represent $\\frac{1}{3}$ using $n$ decimal digits then we have to chop off the digits to the right that we cannot include, thereby rounding the number. We lose some amount of precision that depends on how many significant digits we retain in our representation.\n\nSo the same is true in binary. There are some real numbers that cannot be represented precisely in binary floating-point format.\n\nSee [here](http://ta.twi.tudelft.nl/users/vuik/wi211/disasters.html) for some examples of significant adverse events (i.e. disasters) cause by numerical errors.\n\nRounding can be used to your advantage, if you're in the business of stealing from people (see [salami slicing](http://en.wikipedia.org/wiki/Salami_slicing)). In the 1980s movie [Superman III](http://en.wikipedia.org/wiki/Superman_III), Richard Pryor's character plays a \"bumbling computer genius\" who embezzles a ton of money by stealing a large number of fractions of cents (which in the movie are said to be lost anyway due to rounding) from his company's payroll (YouTube clip [here](http://www.youtube.com/watch?v=iLw9OBV7HYA)).\n\nThere is a comprehensive theoretical summary of these issues here: [What Every Computer Scientist Should Know About Floating-Point Arithmetic](http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html).\n\nHere is a fantastic blog post that takes you through how floating-point numbers are represented:\n\n[Exposing Floating\nPoint](https://ciechanow.ski/exposing-floating-point/)\n\nFinally here is a recent post by Julia Evans in which she discusses different [Examples of floating point problems](https://jvns.ca/blog/2023/01/13/examples-of-floating-point-problems/)\n\nand another post by Julia Evans in which she goes through the actual floating-point arithmetic that underlies the `0.1 + 0.2 == 0.3` problem: [Why does 0.1 + 0.2 = 0.30000000000000004?](https://jvns.ca/blog/2023/02/08/why-does-0-1-plus-0-2-equal-0-30000000000000004/)\n\n## Integer Overflow\n\nJust in case you thought that floating point values are the only source of problems, representing integer values also comes with the problem of *integer overflow*. This is when one attempts to represent an integer that is larger than possible given the number of bits available.\n\nSo for example if we were representing positive integers using only 16 bits, we would only be able to store $2^{16}=65536$ distinct values. So if the first value is $0$ then we are able to store positive integers up to $65535$. If we attempt to add the value $1$ to a variable that uses 16 bits and is currently storing the value $65535$, the variable will \"overflow\", probably back to zero, in this case.\n\nHere is a not-well-enough-known recent case of integer overflow error affecting Boeing's new 787 \"Dreamliner\" aircraft:\n\n[Reboot Your Dreamliner Every 248 Days To Avoid Integer Overflow](https://www.i-programmer.info/news/149 security/8548-reboot-your-dreamliner-every-248-days-to-avoid-integer-overflow.html)\n\n## Floating point precision\n\nOne non-intuitive feature of floating point representations is that the precision varies with the magnitude of the number being represented. That is, the \"next possible representable number\" is a very small step away from the current number, when the number is relatively small... but it becomes very large indeed when the numbers are large, sitting far along the number line.\n\nIn Python the `numpy` package has a function called `nextafter()` that will report the next representable value from a given value towards a second value:\n\n::: {#7aebe4ba .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nx = 1.234\nx2 = np.nextafter(x, +np.inf)\nprint(f\"smallest possible increment after {x} is\\n {x2-x:0.20f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsmallest possible increment after 1.234 is\n 0.00000000000000022204\n```\n:::\n:::\n\n\nNow let's try this with a larger number:\n\n::: {#eb5214c9 .cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\nx = 1234567890.123\nx2 = np.nextafter(x, +np.inf)\nprint(f\"smallest possible increment after {x} is\\n {x2-x:0.20f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsmallest possible increment after 1234567890.123 is\n 0.00000023841857910156\n```\n:::\n:::\n\n\nNow let's try a much larger number:\n\n::: {#4483efd5 .cell execution_count=7}\n``` {.python .cell-code}\nimport numpy as np\nx = 1.234 * 10**25\nx2 = np.nextafter(x, +np.inf)\nprint(f\"smallest possible increment after {x} is\\n {x2-x:0.1f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsmallest possible increment after 1.2340000000000001e+25 is\n 2147483648.0\n```\n:::\n:::\n\n\nSo if `x` is `1.234 * 10**25` (admittedly a large number) then the next number that is possible to represent with floating point arithmetic is more than **two billion**! That's a big \"step\" along the number line.\n\nThis is a consequence of the floating-point representation of numbers. If you are regularly dealing with very large numbers then you should be aware of this.\n\n\n## Size of Python built-in types\n\nIn Python we can query the size (in bytes) of a given variable using the function `getsizeof()` which is part of the `sys` module:\n\n::: {#8dc83b5b .cell execution_count=8}\n``` {.python .cell-code}\nimport sys\n\na = int(12)\nprint(f\"the {type(a)} {a} uses {sys.getsizeof(a)} bytes\")\n\nb = 123.456\nprint(f\"the {type(b)} {b} uses {sys.getsizeof(b)} bytes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe <class 'int'> 12 uses 28 bytes\nthe <class 'float'> 123.456 uses 24 bytes\n```\n:::\n:::\n\n\nIn Python (version 3 and above) integer variables start off using a certain number of bytes but if necessary they will expand.\n\n::: {#817828a9 .cell execution_count=9}\n``` {.python .cell-code}\na = 1234567890987654321234567891\nprint(f\"the {type(a)} {a} uses {sys.getsizeof(a)} bytes\")\n\nb = a * 10\nprint(f\"the {type(b)} {b} uses {sys.getsizeof(b)} bytes\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthe <class 'int'> 1234567890987654321234567891 uses 36 bytes\nthe <class 'int'> 12345678909876543212345678910 uses 40 bytes\n```\n:::\n:::\n\n\nOf course there are limits governed for integers by the size of your system's memory.\n\nIn the case of floating-point values, the limit of 64 bits for the IEEE [double-precision floating point format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format):\n\n::: {#615c6b4c .cell execution_count=10}\n``` {.python .cell-code}\nprint(sys.float_info.max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.7976931348623157e+308\n```\n:::\n:::\n\n\n## ASCII\n\nASCII stands for *American Standard Code for Information Interchange*. ASCII codes delineate how text is represented in digital format for computers (as well as other communications equipment).\n\nASCII uses a 7-bit binary code to represent 128 specific characters of text. The first 32 codes (decimal 0 through 31) are non-printable codes like `TAB`, `BEL` (play a bell sound), `CR` (carriage return), etc. Decimal codes 32 through 47 are more typical text symbols like `#` and `&`. Decimal codes 48 through 57 are the numbers `0` through `9`:\n\n::: {#9dac4a88 .cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"Dec Hex Oct Chr\")\nprint(\"--- --- --- ---\")\nfor n in range(48,58,1):\n    print(f\"{n:3d}  {n:x}  {n:o}   {chr(n)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDec Hex Oct Chr\n--- --- --- ---\n 48  30  60   0\n 49  31  61   1\n 50  32  62   2\n 51  33  63   3\n 52  34  64   4\n 53  35  65   5\n 54  36  66   6\n 55  37  67   7\n 56  38  70   8\n 57  39  71   9\n```\n:::\n:::\n\n\nDecimal codes 65 through 90 are capital letters `A` through `Z`, and\ncodes 97 through 122 are lowercase letters `a` through `z`:\n\n::: {#9420c450 .cell execution_count=12}\n``` {.python .cell-code code-fold=\"true\"}\nprint(\"Dec Hex Oct Chr      Dec Hex Oct Chr\")\nprint(\"--- --- --- ---      --- --- --- ---\")\nfor n in range(65,91,1):\n    print(f\"{n:3d}  {n:x} {n:o}   {chr(n)}      {n+32:3d}  {n+32:x} {n+32:o}   {chr(n+32)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDec Hex Oct Chr      Dec Hex Oct Chr\n--- --- --- ---      --- --- --- ---\n 65  41 101   A       97  61 141   a\n 66  42 102   B       98  62 142   b\n 67  43 103   C       99  63 143   c\n 68  44 104   D      100  64 144   d\n 69  45 105   E      101  65 145   e\n 70  46 106   F      102  66 146   f\n 71  47 107   G      103  67 147   g\n 72  48 110   H      104  68 150   h\n 73  49 111   I      105  69 151   i\n 74  4a 112   J      106  6a 152   j\n 75  4b 113   K      107  6b 153   k\n 76  4c 114   L      108  6c 154   l\n 77  4d 115   M      109  6d 155   m\n 78  4e 116   N      110  6e 156   n\n 79  4f 117   O      111  6f 157   o\n 80  50 120   P      112  70 160   p\n 81  51 121   Q      113  71 161   q\n 82  52 122   R      114  72 162   r\n 83  53 123   S      115  73 163   s\n 84  54 124   T      116  74 164   t\n 85  55 125   U      117  75 165   u\n 86  56 126   V      118  76 166   v\n 87  57 127   W      119  77 167   w\n 88  58 130   X      120  78 170   x\n 89  59 131   Y      121  79 171   y\n 90  5a 132   Z      122  7a 172   z\n```\n:::\n:::\n\n\nFor a full description of the 7-bit ascii codes in their entirety, including the *extended ASCII codes* (where you will find things like Ã¶ and Ã©), see this webpage:\n\n<http://www.asciitable.com> (ASCII Table and Extended ASCII Codes).\n\nIn Python you can find the ASCII integer value of a character using the `ord()` function. You can get the character value of an ASCII code using the `chr()` function.\n\n::: {#b42b2cc0 .cell execution_count=13}\n``` {.python .cell-code}\nord('A')\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n65\n```\n:::\n:::\n\n\n::: {#d41e0bf0 .cell execution_count=14}\n``` {.python .cell-code}\nchr(65)\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n'A'\n```\n:::\n:::\n\n\nYou can use your knowledge of ASCII codes to do clever things, like convert to and from uppercase and lowercase, given your knowledge that the difference (in decimal) between ASCII `A` and ASCII `a` is 32 (see the ASCII table above):\n\n::: {#584b1d75 .cell execution_count=15}\n``` {.python .cell-code}\nchr(ord('A')+32)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n'a'\n```\n:::\n:::\n\n\n::: {#fbe51d05 .cell execution_count=16}\n``` {.python .cell-code}\nchr(ord('a')-32)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n'A'\n```\n:::\n:::\n\n\nOf course in Python there are more straightforward ways to convert between upper and lower case:\n\n::: {#a46054fe .cell execution_count=17}\n``` {.python .cell-code}\n'a'.upper()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n'A'\n```\n:::\n:::\n\n\n::: {#61c374ac .cell execution_count=18}\n``` {.python .cell-code}\n'A'.lower()\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n'a'\n```\n:::\n:::\n\n\n## Unicode\n\nThe ASCII codes only represent a limited number of characters that are useful mostly in the English language. Starting in the 1980s, Xerox, Apple, and others began work on a new variable-length encoding scheme that could represent a much larger number of characters that would be useful for the world's languages (and now even for [emoji](https://en.wikipedia.org/wiki/Emoji)). This is called [Unicode](https://en.wikipedia.org/wiki/Unicode) and includes the most common standard on the web, [UTF-8](https://en.wikipedia.org/wiki/UTF-8), which can encode more than a million different characters and symbols.\n\nHere is a website where you can view and search the [Unicode character table](https://unicode-table.com/en/blocks/). \n\nFor example, in Unicode the [smiling face emoji](https://unicode-table.com/en/1F600/) &#128512; is encoded using hexadecimal value `1F600`:\n\n::: {#312257ef .cell execution_count=19}\n``` {.python .cell-code}\nprint(f\"Unicode (hex) 1f600 is {chr(0x1f600)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnicode (hex) 1f600 is ðŸ˜€\n```\n:::\n:::\n\n\n",
    "supporting": [
      "digital_representation_of_data_files"
    ],
    "filters": [],
    "includes": {}
  }
}